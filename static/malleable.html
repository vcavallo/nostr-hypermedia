<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Malleable UI - Nostr Hypermedia</title>

  <!-- Alpine.js for reactivity -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #e0e0e0;
      background: #0d1117;
      min-height: 100vh;
    }

    .app {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background: linear-gradient(135deg, #238636 0%, #1f6feb 100%);
      color: white;
      padding: 24px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
    }

    header h1 { font-size: 24px; margin-bottom: 4px; }
    header .subtitle { opacity: 0.9; font-size: 14px; }

    .controls {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .controls label {
      display: block;
      font-size: 13px;
      color: #8b949e;
      margin-bottom: 6px;
    }

    .controls input, .controls textarea {
      width: 100%;
      padding: 10px 12px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 14px;
      font-family: inherit;
    }

    .controls input.mono {
      font-family: monospace;
    }

    .controls textarea {
      min-height: 80px;
      resize: vertical;
    }

    .controls input:focus, .controls textarea:focus {
      outline: none;
      border-color: #238636;
    }

    .controls .actions {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .input-row {
      margin-bottom: 12px;
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-primary {
      background: #238636;
      color: white;
    }
    .btn-primary:hover { background: #2ea043; }
    .btn-primary:disabled { background: #21262d; color: #484f58; cursor: not-allowed; }

    .btn-secondary {
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
    }
    .btn-secondary:hover { background: #30363d; }

    .btn-large {
      padding: 12px 24px;
      font-size: 16px;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #8b949e;
      margin-top: 12px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #484f58;
    }
    .status-dot.connected { background: #238636; }
    .status-dot.loading { background: #f0883e; animation: pulse 1s infinite; }
    .status-dot.error { background: #f85149; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .error-box {
      background: #f8514922;
      border: 1px solid #f85149;
      color: #f85149;
      padding: 12px 16px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 14px;
    }

    .success-box {
      background: #23863622;
      border: 1px solid #238636;
      color: #3fb950;
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
    }

    .success-box .nevent-id {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      background: #0d1117;
      padding: 10px 12px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 12px;
      word-break: break-all;
      color: #58a6ff;
    }

    .success-box .copy-btn {
      flex-shrink: 0;
      padding: 6px 12px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #c9d1d9;
      cursor: pointer;
      font-size: 12px;
    }

    .success-box .copy-btn:hover {
      background: #30363d;
    }

    .success-box .dismiss-btn {
      float: right;
      background: none;
      border: none;
      color: #8b949e;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
    }

    .success-box .dismiss-btn:hover {
      color: #c9d1d9;
    }

    .waiting-box {
      background: #1f6feb22;
      border: 1px solid #1f6feb;
      color: #58a6ff;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
    }

    .waiting-box .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #58a6ff;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .event-meta {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      font-size: 13px;
    }

    .event-meta dt {
      color: #8b949e;
      font-weight: 500;
    }

    .event-meta dd {
      color: #c9d1d9;
      font-family: monospace;
      margin-bottom: 8px;
      word-break: break-all;
    }

    .raw-json {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 12px;
      font-family: monospace;
      font-size: 12px;
      color: #8b949e;
      white-space: pre-wrap;
      overflow-x: auto;
      max-height: 200px;
      overflow-y: auto;
    }

    /* Rendered UI styles */
    .rendered-ui {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 20px;
    }

    .ui-card {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 20px;
    }

    .ui-heading {
      font-size: 22px;
      font-weight: 600;
      color: #e0e0e0;
      margin: 16px 0 8px 0;
    }
    .ui-heading:first-child { margin-top: 0; }

    .ui-text {
      color: #8b949e;
      margin: 8px 0;
    }

    .ui-image {
      max-width: 100%;
      border-radius: 8px;
      margin: 12px 0;
    }

    .ui-link {
      color: #58a6ff;
      text-decoration: none;
    }
    .ui-link:hover { text-decoration: underline; }

    .ui-container {
      margin: 12px 0;
    }
    .ui-container.options {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .ui-button {
      background: #238636;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    .ui-button:hover { background: #2ea043; }
    .ui-button:disabled { background: #21262d; color: #484f58; cursor: wait; }

    .ui-input {
      background: #0d1117;
      border: 1px solid #30363d;
      color: #e0e0e0;
      padding: 10px 12px;
      border-radius: 6px;
      width: 100%;
      margin: 8px 0;
    }

    .ui-label {
      display: block;
      color: #8b949e;
      font-size: 13px;
      margin: 8px 0 4px 0;
    }

    .ui-hr {
      border: none;
      border-top: 1px solid #30363d;
      margin: 16px 0;
    }

    .ui-data {
      background: #0d1117;
      padding: 6px 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
      color: #58a6ff;
      display: inline-block;
      margin: 4px 0;
    }

    .ui-data-label {
      color: #8b949e;
      margin-right: 6px;
    }

    .user-info {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 13px;
    }

    .user-info .pubkey {
      font-family: monospace;
      color: #58a6ff;
    }

    .mode-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
    }

    .mode-tab {
      flex: 1;
      padding: 12px 20px;
      background: #21262d;
      border: 1px solid #30363d;
      color: #8b949e;
      cursor: pointer;
      font-size: 14px;
      text-align: center;
      transition: all 0.2s;
    }

    .mode-tab:first-child {
      border-radius: 8px 0 0 8px;
    }

    .mode-tab:last-child {
      border-radius: 0 8px 8px 0;
      border-left: none;
    }

    .mode-tab.active {
      background: #238636;
      border-color: #238636;
      color: white;
    }

    .mode-tab:hover:not(.active) {
      background: #30363d;
    }

    .bot-config {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .bot-config label {
      display: block;
      font-size: 13px;
      color: #8b949e;
      margin-bottom: 6px;
    }

    .bot-config input {
      width: 100%;
      padding: 10px 12px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 14px;
      font-family: monospace;
    }

    .bot-config .hint {
      font-size: 12px;
      color: #6e7681;
      margin-top: 4px;
    }

    .request-area {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .request-area h3 {
      font-size: 16px;
      color: #e0e0e0;
      margin-bottom: 12px;
    }

    .request-area textarea {
      width: 100%;
      min-height: 100px;
      padding: 12px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 14px;
      resize: vertical;
      margin-bottom: 12px;
    }

    .request-area textarea:focus {
      outline: none;
      border-color: #238636;
    }

    .examples-hint {
      font-size: 13px;
      color: #8b949e;
      margin-bottom: 12px;
    }

    .example-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .example-chip {
      padding: 6px 12px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 20px;
      color: #8b949e;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .example-chip:hover {
      background: #30363d;
      color: #e0e0e0;
    }

    /* New element type styles */
    .ui-query {
      margin: 8px 0;
    }

    .ui-foreach {
      margin: 8px 0;
    }

    .ui-foreach > * {
      margin-bottom: 8px;
    }

    .ui-embed {
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      background: #0d1117;
    }

    .ui-error {
      background: #f8514922;
      border: 1px solid #f85149;
      color: #f85149;
      padding: 10px 14px;
      border-radius: 6px;
      margin: 8px 0;
      font-size: 13px;
    }

    .ui-embed-error {
      color: #8b949e;
      font-style: italic;
      padding: 8px;
    }

    /* State-aware button */
    .ui-button[data-state-action] {
      transition: all 0.2s;
    }

    /* Loading state for query */
    .ui-query-loading {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #8b949e;
      padding: 12px;
    }

    .ui-query-loading::before {
      content: '';
      width: 16px;
      height: 16px;
      border: 2px solid #30363d;
      border-top-color: #58a6ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Event preview in foreach */
    .ui-event-preview {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 12px;
      margin: 6px 0;
    }

    .ui-event-preview .author {
      font-family: monospace;
      font-size: 12px;
      color: #58a6ff;
    }

    .ui-event-preview .content {
      margin-top: 6px;
      color: #c9d1d9;
    }

    .ui-event-preview .time {
      font-size: 11px;
      color: #6e7681;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div class="app" x-data="malleableApp()">
    <header>
      <h1>Malleable UI</h1>
      <div class="subtitle">Request custom apps from the bot, or load existing ones</div>
    </header>

    <!-- User connection status -->
    <div class="user-info" x-show="userPubkey">
      <span>Connected as: <span class="pubkey" x-text="userPubkey ? userPubkey.slice(0, 8) + '...' + userPubkey.slice(-4) : ''"></span></span>
      <button class="btn btn-secondary" @click="disconnect()">Disconnect</button>
    </div>

    <div class="user-info" x-show="!userPubkey">
      <span>Not connected - NIP-07 extension required</span>
      <button class="btn btn-primary" @click="connect()">Connect</button>
    </div>

    <!-- Mode Tabs -->
    <div class="mode-tabs">
      <div class="mode-tab" :class="{ active: mode === 'request' }" @click="mode = 'request'">
        Request New App
      </div>
      <div class="mode-tab" :class="{ active: mode === 'load' }" @click="mode = 'load'">
        Load Existing
      </div>
    </div>

    <!-- DVM Service Provider Configuration -->
    <div class="bot-config" x-show="mode === 'request'">
      <label for="bot-npub">DVM Service Provider (NPub)</label>
      <input
        type="text"
        id="bot-npub"
        x-model="botNpub"
        placeholder="npub1..."
      >
      <div class="hint">NIP-90 Data Vending Machine that generates UI specs (kind:5666/6666). Default: npub1h00x5r5gglsumv46tmqzrny5n6euauf9hqcy5ay0uywqgpuepmkq5x62ut</div>
    </div>

    <!-- Request Mode -->
    <div class="request-area" x-show="mode === 'request'">
      <h3>Describe the app you want</h3>

      <div class="examples-hint">Try one of these examples or write your own:</div>
      <div class="example-chips">
        <span class="example-chip" @click="setExample('poll')">Poll about pizza toppings</span>
        <span class="example-chip" @click="setExample('rsvp')">RSVP for a meetup</span>
        <span class="example-chip" @click="setExample('feedback')">Feedback form</span>
        <span class="example-chip" @click="setExample('quiz')">Quick quiz</span>
        <span class="example-chip" @click="setExample('counter')">Like button</span>
      </div>

      <textarea
        x-model="requestText"
        placeholder="Describe what you want... e.g., 'make a poll asking what people's favorite programming language is with options for Python, JavaScript, Rust, and Go'"
        @keydown.meta.enter="sendRequest()"
        @keydown.ctrl.enter="sendRequest()"
      ></textarea>

      <button
        class="btn btn-primary btn-large"
        @click="sendRequest()"
        :disabled="!userPubkey || !requestText.trim() || waiting"
      >
        <span x-show="!waiting">Send Request</span>
        <span x-show="waiting">Waiting for response...</span>
      </button>

      <div class="status" x-show="!userPubkey" style="color: #f0883e;">
        Connect your NIP-07 extension to send requests
      </div>
    </div>

    <!-- Waiting for response -->
    <div class="waiting-box" x-show="waiting">
      <span class="spinner"></span>
      <span>Waiting for DVM job result (kind:6666)...</span>
      <div style="margin-top: 10px; font-size: 12px; color: #8b949e;">
        Job request (kind:5666): <span x-text="sentRequestId ? sentRequestId.slice(0, 8) + '...' : ''"></span>
      </div>
    </div>

    <!-- Load Mode -->
    <div class="controls" x-show="mode === 'load'">
      <label for="event-id">Event ID, nevent, naddr, or note (or paste a UI spec JSON)</label>
      <input
        type="text"
        id="event-id"
        class="mono"
        x-model="eventInput"
        @keydown.enter="loadEvent()"
        placeholder="paste event id, nevent1..., or JSON UI spec"
      >
      <div class="actions">
        <button class="btn btn-primary" @click="loadEvent()" :disabled="loading">
          <span x-show="!loading">Load Event</span>
          <span x-show="loading">Loading...</span>
        </button>
        <button class="btn btn-secondary" @click="loadDemo('poll')">Poll Demo</button>
        <button class="btn btn-secondary" @click="loadDemo('feed')">Feed Demo</button>
        <button class="btn btn-secondary" @click="loadDemo('conditional')">If/Else Demo</button>
        <button class="btn btn-secondary" @click="loadDemo('counter')">Counter Demo</button>
        <button class="btn btn-secondary" @click="loadDemo('profile')">Profile Demo</button>
        <button class="btn btn-secondary" @click="clear()">Clear</button>
      </div>
    </div>

    <!-- Connection status -->
    <div class="status" style="margin-bottom: 20px;">
      <span class="status-dot" :class="{'connected': relayStatus === 'connected', 'loading': relayStatus === 'connecting', 'error': relayStatus === 'error'}"></span>
      <span x-text="statusMessage"></span>
    </div>

    <!-- Error display -->
    <div class="error-box" x-show="error" x-text="error"></div>

    <!-- Success display -->
    <div class="success-box" x-show="successMessage">
      <button class="dismiss-btn" @click="dismissSuccess()">&times;</button>
      <div x-text="successMessage"></div>
      <div class="nevent-id" x-show="successNevent">
        <span x-text="successNevent"></span>
        <button class="copy-btn" @click="copyNevent()">Copy</button>
      </div>
    </div>

    <!-- Event metadata -->
    <div class="event-meta" x-show="event && !isDirectSpec">
      <dl>
        <dt>Event ID</dt>
        <dd x-text="event?.id"></dd>
        <dt>Author</dt>
        <dd x-text="event?.pubkey"></dd>
        <dt>Kind</dt>
        <dd x-text="event?.kind"></dd>
        <dt>Created</dt>
        <dd x-text="event ? new Date(event.created_at * 1000).toLocaleString() : ''"></dd>
      </dl>
    </div>

    <!-- Rendered UI -->
    <div class="rendered-ui" x-show="uiSpec">
      <div x-html="renderedHtml"></div>
    </div>

    <!-- Raw content (if not a UI spec) -->
    <div x-show="event && !uiSpec && !isDirectSpec">
      <h3 style="color: #8b949e; font-size: 14px; margin-bottom: 10px;">Raw Content (not a UI spec)</h3>
      <div class="raw-json" x-text="event?.content"></div>
    </div>

    <!-- Raw spec display -->
    <details x-show="uiSpec" style="margin-top: 20px;">
      <summary style="color: #8b949e; cursor: pointer; font-size: 13px;">View raw UI spec</summary>
      <div class="raw-json" style="margin-top: 10px;" x-text="JSON.stringify(uiSpec, null, 2)"></div>
    </details>
  </div>

  <script>
    // ===========================================
    // Vanilla JS: Relay connection & note fetching
    // ===========================================

    const DEFAULT_RELAYS = [
      'wss://relay.damus.io',
      'wss://relay.nostr.band',
      'wss://nos.lol',
      'wss://relay.primal.net'
    ];

    // Default malleable-bot npub
    const DEFAULT_BOT_NPUB = 'npub1h00x5r5gglsumv46tmqzrny5n6euauf9hqcy5ay0uywqgpuepmkq5x62ut';

    // NIP-90 DVM kinds for malleable UI generation
    const KIND_JOB_REQUEST = 5666;
    const KIND_JOB_RESULT = 6666;

    class RelayPool {
      constructor(relays = DEFAULT_RELAYS) {
        this.relays = relays;
        this.sockets = new Map();
        this.subscriptions = new Map();
        this.subCounter = 0;
      }

      async connect() {
        const promises = this.relays.map(url => this.connectRelay(url));
        await Promise.allSettled(promises);
        return this.sockets.size > 0;
      }

      connectRelay(url) {
        return new Promise((resolve, reject) => {
          if (this.sockets.has(url)) {
            resolve(this.sockets.get(url));
            return;
          }

          const ws = new WebSocket(url);
          const timeout = setTimeout(() => {
            ws.close();
            reject(new Error(`Timeout connecting to ${url}`));
          }, 5000);

          ws.onopen = () => {
            clearTimeout(timeout);
            this.sockets.set(url, ws);
            resolve(ws);
          };

          ws.onerror = (err) => {
            clearTimeout(timeout);
            reject(err);
          };

          ws.onclose = () => {
            this.sockets.delete(url);
          };

          ws.onmessage = (msg) => {
            try {
              const data = JSON.parse(msg.data);
              this.handleMessage(url, data);
            } catch (e) {
              console.error('Failed to parse message:', e);
            }
          };
        });
      }

      handleMessage(relay, data) {
        const [type, subId, ...rest] = data;

        if (type === 'EVENT') {
          const event = rest[0];
          const sub = this.subscriptions.get(subId);
          if (sub && sub.onEvent) {
            sub.onEvent(event, relay);
          }
        } else if (type === 'EOSE') {
          const sub = this.subscriptions.get(subId);
          if (sub) {
            sub.eoseCount = (sub.eoseCount || 0) + 1;
            if (sub.eoseCount >= this.sockets.size && sub.onEose) {
              sub.onEose();
            }
          }
        }
      }

      subscribe(filter, { onEvent, onEose }) {
        const subId = `sub_${++this.subCounter}`;
        this.subscriptions.set(subId, { filter, onEvent, onEose, eoseCount: 0 });

        const req = JSON.stringify(['REQ', subId, filter]);
        this.sockets.forEach(ws => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(req);
          }
        });

        return subId;
      }

      unsubscribe(subId) {
        const close = JSON.stringify(['CLOSE', subId]);
        this.sockets.forEach(ws => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(close);
          }
        });
        this.subscriptions.delete(subId);
      }

      async fetchEvent(filter, timeout = 5000) {
        return new Promise((resolve) => {
          let event = null;
          let timer;

          const subId = this.subscribe(filter, {
            onEvent: (e) => {
              if (!event || e.created_at > event.created_at) {
                event = e;
              }
            },
            onEose: () => {
              clearTimeout(timer);
              this.unsubscribe(subId);
              resolve(event);
            }
          });

          timer = setTimeout(() => {
            this.unsubscribe(subId);
            resolve(event);
          }, timeout);
        });
      }

      // Subscribe and wait for a specific event (reply to our request)
      waitForReply(filter, timeout = 60000) {
        return new Promise((resolve, reject) => {
          let timer;

          const subId = this.subscribe(filter, {
            onEvent: (event) => {
              clearTimeout(timer);
              this.unsubscribe(subId);
              resolve(event);
            },
            onEose: () => {
              // Don't resolve on EOSE - keep waiting for live events
            }
          });

          timer = setTimeout(() => {
            this.unsubscribe(subId);
            reject(new Error('Timeout waiting for bot response'));
          }, timeout);
        });
      }

      async publish(event) {
        const msg = JSON.stringify(['EVENT', event]);
        const results = [];

        this.sockets.forEach((ws, url) => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(msg);
            results.push(url);
          }
        });

        return results;
      }

      close() {
        this.sockets.forEach(ws => ws.close());
        this.sockets.clear();
        this.subscriptions.clear();
      }
    }

    // ===========================================
    // Vanilla JS: UI Spec Interpreter
    // ===========================================

    function parseUISpec(content) {
      if (typeof content !== 'string') return null;
      content = content.trim();
      if (!content.startsWith('{')) return null;

      try {
        // Try wrapped format {"ui": {...}}
        const parsed = JSON.parse(content);
        if (parsed.ui && parsed.ui.elements) {
          return parsed.ui;
        }
        // Try direct format {elements: [...]}
        if (parsed.elements && Array.isArray(parsed.elements)) {
          return parsed;
        }
      } catch (e) {
        console.log('Not valid JSON:', e.message);
      }

      return null;
    }

    // Global reference to relay pool for queries
    let _globalPool = null;

    function setGlobalPool(pool) {
      _globalPool = pool;
    }

    // Async render that supports query, foreach, if/else, embed, state
    async function renderUISpec(spec, ctx, actionHandler) {
      let html = '';

      // Initialize state if spec has state definition
      if (spec.state) {
        ctx._state = { ...spec.state };
      }

      // Process computed values
      if (spec.computed) {
        ctx._computed = {};
        for (const [key, expr] of Object.entries(spec.computed)) {
          ctx._computed[key] = evaluateExpression(expr, ctx);
        }
      }

      if (spec.style) {
        html += `<style>${escapeHtml(spec.style)}</style>`;
      }

      const layoutClass = spec.layout ? `ui-${spec.layout}` : 'ui-card';
      html += `<div class="${layoutClass}">`;

      for (const elem of spec.elements || []) {
        html += await renderElement(elem, ctx, spec.actions || [], actionHandler, spec);
      }

      html += '</div>';
      return html;
    }

    async function renderElement(elem, ctx, actions, actionHandler, spec) {
      const value = elem.bind ? resolveBind(elem.bind, ctx) : (elem.value || '');
      const id = elem.id ? ` id="${escapeHtml(elem.id)}"` : '';

      switch (elem.type) {
        case 'heading':
        case 'h1':
        case 'h2':
        case 'h3':
          return `<h2 class="ui-heading"${id}>${escapeHtml(value)}</h2>`;

        case 'text':
        case 'p':
          return `<p class="ui-text"${id}>${escapeHtml(value)}</p>`;

        case 'image':
        case 'img':
          const src = elem.src || value;
          return `<img class="ui-image"${id} src="${escapeHtml(src)}" alt="">`;

        case 'link':
        case 'a':
          const href = elem.href || value;
          const label = elem.label || value;
          return `<a class="ui-link"${id} href="${escapeHtml(href)}">${escapeHtml(label)}</a>`;

        case 'button':
          const btnLabel = elem.label || value;
          if (elem.action) {
            const action = actions.find(a => a.id === elem.action);
            if (action) {
              const actionId = `action_${Math.random().toString(36).slice(2, 8)}`;
              window._malleableActions = window._malleableActions || {};
              window._malleableActions[actionId] = { action, ctx, spec };
              return `<button class="ui-button"${id} onclick="window.executeAction('${actionId}')">${escapeHtml(btnLabel)}</button>`;
            }
          }
          if (elem.href) {
            return `<a class="ui-button"${id} href="${escapeHtml(elem.href)}">${escapeHtml(btnLabel)}</a>`;
          }
          return `<button class="ui-button"${id}>${escapeHtml(btnLabel)}</button>`;

        case 'input':
          const inputLabel = elem.label;
          const name = elem.name || elem.id || '';
          let inputHtml = '';
          if (inputLabel) {
            inputHtml += `<label class="ui-label" for="${escapeHtml(name)}">${escapeHtml(inputLabel)}</label>`;
          }
          inputHtml += `<input class="ui-input"${id} name="${escapeHtml(name)}" type="text" value="${escapeHtml(value)}">`;
          return inputHtml;

        case 'container':
        case 'div':
          const containerClass = elem.style && !elem.style.includes(':')
            ? `ui-container ${elem.style}`
            : 'ui-container';
          let containerHtml = `<div class="${containerClass}"${id}>`;
          for (const child of elem.children || []) {
            containerHtml += await renderElement(child, ctx, actions, actionHandler, spec);
          }
          containerHtml += '</div>';
          return containerHtml;

        case 'hr':
          return '<hr class="ui-hr">';

        case 'data':
          const dataLabel = elem.label;
          if (dataLabel) {
            return `<span class="ui-data"${id}><span class="ui-data-label">${escapeHtml(dataLabel)}</span>${escapeHtml(value)}</span>`;
          }
          return `<span class="ui-data"${id}>${escapeHtml(value)}</span>`;

        // === NEW ELEMENT TYPES ===

        // QUERY: Fetch events from relays
        case 'query':
          return await renderQuery(elem, ctx, actions, actionHandler, spec);

        // FOREACH: Iterate over arrays
        case 'foreach':
          return await renderForeach(elem, ctx, actions, actionHandler, spec);

        // IF: Conditional rendering
        case 'if':
          return await renderIf(elem, ctx, actions, actionHandler, spec);

        // EMBED: Embed another malleable UI by event ID
        case 'embed':
          return await renderEmbed(elem, ctx, actions, actionHandler);

        // STATE-DISPLAY: Show current state value
        case 'state-value':
          const stateKey = elem.key || elem.bind?.replace('$.state.', '');
          const stateVal = ctx._state?.[stateKey] ?? '';
          return `<span class="ui-data"${id}>${escapeHtml(String(stateVal))}</span>`;

        // EVAL: Evaluate JS expression and display result or store in context
        case 'eval':
          return renderEval(elem, ctx, actions, actionHandler, spec);

        // SCRIPT: Execute arbitrary JS and optionally render result
        case 'script':
          return renderScript(elem, ctx);

        default:
          return '';
      }
    }

    // Render QUERY element - fetches events and renders children with results
    async function renderQuery(elem, ctx, actions, actionHandler, spec) {
      if (!_globalPool) {
        return `<div class="ui-error">Query failed: No relay connection</div>`;
      }

      // Support both 'filter' and 'filters' (first filter in array)
      let filterObj = elem.filter || (Array.isArray(elem.filters) ? elem.filters[0] : elem.filters);
      if (!filterObj) {
        return `<div class="ui-error">Query: No filter specified</div>`;
      }

      // Resolve any template variables in the filter
      const filter = resolveFilterTemplates(filterObj, ctx);
      const varName = elem.as || 'results';

      try {
        // Fetch events
        const events = await fetchEvents(_globalPool, filter, elem.timeout || 5000);

        // Store results in context
        const newCtx = { ...ctx, [varName]: events };

        // Render children with the new context
        let html = `<div class="ui-query" data-var="${escapeHtml(varName)}">`;

        if (events.length === 0 && elem.empty) {
          // Render empty state
          for (const child of elem.empty) {
            html += await renderElement(child, newCtx, actions, actionHandler, spec);
          }
        } else if (elem.children) {
          for (const child of elem.children) {
            html += await renderElement(child, newCtx, actions, actionHandler, spec);
          }
        } else {
          // No children - just show count
          html += `<div class="ui-text">Query returned ${events.length} event(s)</div>`;
        }

        html += '</div>';
        return html;
      } catch (e) {
        console.error('Query failed:', e);
        return `<div class="ui-error">Query failed: ${escapeHtml(e.message)}</div>`;
      }
    }

    // Render FOREACH element - iterates over array and renders template
    async function renderForeach(elem, ctx, actions, actionHandler, spec) {
      const items = resolvePath(elem.items, ctx) || [];
      const varName = elem.as || 'item';
      const indexName = elem.index || 'index';

      let html = '<div class="ui-foreach">';

      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        // Create new context with item and index
        const itemCtx = {
          ...ctx,
          [varName]: item,
          [indexName]: i,
          // Also expose item properties at top level if it's an event
          ...(item.id ? { _item: item } : {})
        };

        // Render template for each item
        if (elem.template) {
          html += await renderElement(elem.template, itemCtx, actions, actionHandler, spec);
        } else if (elem.children) {
          for (const child of elem.children) {
            html += await renderElement(child, itemCtx, actions, actionHandler, spec);
          }
        }
      }

      html += '</div>';
      return html;
    }

    // Render IF element - conditional rendering
    async function renderIf(elem, ctx, actions, actionHandler, spec) {
      const condition = evaluateCondition(elem.condition, ctx);

      let html = '';
      if (condition) {
        if (elem.then) {
          if (Array.isArray(elem.then)) {
            for (const child of elem.then) {
              html += await renderElement(child, ctx, actions, actionHandler, spec);
            }
          } else {
            html += await renderElement(elem.then, ctx, actions, actionHandler, spec);
          }
        }
      } else {
        if (elem.else) {
          if (Array.isArray(elem.else)) {
            for (const child of elem.else) {
              html += await renderElement(child, ctx, actions, actionHandler, spec);
            }
          } else {
            html += await renderElement(elem.else, ctx, actions, actionHandler, spec);
          }
        }
      }

      return html;
    }

    // Render EVAL element - evaluate a JS expression and optionally store/display
    function renderEval(elem, ctx, actions, actionHandler, spec) {
      const expr = elem.expr || elem.expression || elem.code;
      if (!expr) {
        return `<div class="ui-error">Eval: No expression provided</div>`;
      }

      try {
        // Create a sandboxed function with context available
        // The expression can access: ctx, Date, Math, JSON, Array, Object, String, Number, Boolean
        const fn = new Function('ctx', 'Date', 'Math', 'JSON', `
          with (ctx) {
            return (${expr});
          }
        `);
        const result = fn(ctx, Date, Math, JSON);

        // Store result in context if 'as' is specified
        if (elem.as) {
          ctx[elem.as] = result;
        }

        // Display result if 'display' is true or not specified
        if (elem.display !== false && !elem.as) {
          return `<span class="ui-data">${escapeHtml(String(result))}</span>`;
        }

        return '';
      } catch (e) {
        console.error('Eval failed:', e);
        return `<div class="ui-error">Eval error: ${escapeHtml(e.message)}</div>`;
      }
    }

    // Render SCRIPT element - execute arbitrary JS, can produce HTML
    function renderScript(elem, ctx) {
      const code = elem.code || elem.script;
      if (!code) {
        return `<div class="ui-error">Script: No code provided</div>`;
      }

      try {
        // Create a sandboxed function that can return HTML
        // Available: ctx, Date, Math, JSON, escapeHtml
        const fn = new Function('ctx', 'Date', 'Math', 'JSON', 'escapeHtml', `
          let html = '';
          const emit = (s) => { html += s; };
          ${code}
          return html;
        `);
        return fn(ctx, Date, Math, JSON, escapeHtml);
      } catch (e) {
        console.error('Script failed:', e);
        return `<div class="ui-error">Script error: ${escapeHtml(e.message)}</div>`;
      }
    }

    // Render EMBED element - embed another malleable UI
    async function renderEmbed(elem, ctx, actions, actionHandler) {
      if (!_globalPool) {
        return `<div class="ui-error">Embed failed: No relay connection</div>`;
      }

      const eventRef = elem.event || elem.id;
      if (!eventRef) {
        return `<div class="ui-error">Embed: No event specified</div>`;
      }

      try {
        // Parse the event reference (could be nevent, note, or hex id)
        const parsed = parseNostrId(eventRef);
        let filter = {};

        if (parsed.type === 'hex' || parsed.type === 'note' || parsed.type === 'nevent') {
          filter = { ids: [parsed.id], limit: 1 };
        } else {
          return `<div class="ui-error">Embed: Invalid event reference</div>`;
        }

        const event = await _globalPool.fetchEvent(filter);
        if (!event) {
          return `<div class="ui-embed-error">Embedded event not found</div>`;
        }

        // Try to parse as UI spec
        const embeddedSpec = parseUISpec(event.content);
        if (embeddedSpec) {
          const embeddedCtx = {
            id: event.id,
            pubkey: event.pubkey,
            created_at: event.created_at,
            kind: event.kind,
            content: event.content
          };
          const embeddedHtml = await renderUISpec(embeddedSpec, embeddedCtx);
          return `<div class="ui-embed">${embeddedHtml}</div>`;
        } else {
          // Not a UI spec, just show content
          return `<div class="ui-embed"><p class="ui-text">${escapeHtml(event.content)}</p></div>`;
        }
      } catch (e) {
        console.error('Embed failed:', e);
        return `<div class="ui-error">Embed failed: ${escapeHtml(e.message)}</div>`;
      }
    }

    // Fetch multiple events from relays
    async function fetchEvents(pool, filter, timeout = 5000) {
      return new Promise((resolve) => {
        const events = [];
        let timer;

        const subId = pool.subscribe(filter, {
          onEvent: (event) => {
            events.push(event);
          },
          onEose: () => {
            clearTimeout(timer);
            pool.unsubscribe(subId);
            // Sort by created_at descending
            events.sort((a, b) => b.created_at - a.created_at);
            resolve(events);
          }
        });

        timer = setTimeout(() => {
          pool.unsubscribe(subId);
          events.sort((a, b) => b.created_at - a.created_at);
          resolve(events);
        }, timeout);
      });
    }

    // Resolve path like "$.results" or "$.item.content" from context
    function resolvePath(path, ctx) {
      if (!path || !ctx) return null;

      // Remove leading $. if present
      const cleanPath = path.replace(/^\$\.?/, '');
      const parts = cleanPath.split('.');

      let value = ctx;
      for (const part of parts) {
        if (value === null || value === undefined) return null;
        value = value[part];
      }

      return value;
    }

    // Resolve template variables in filter object
    function resolveFilterTemplates(filter, ctx) {
      if (!filter) return {};

      const resolved = {};
      for (const [key, value] of Object.entries(filter)) {
        if (typeof value === 'string' && value.includes('{{')) {
          resolved[key] = resolveTemplate(value, ctx);
        } else if (Array.isArray(value)) {
          resolved[key] = value.map(v =>
            typeof v === 'string' && v.includes('{{') ? resolveTemplate(v, ctx) : v
          );
        } else {
          resolved[key] = value;
        }
      }
      return resolved;
    }

    // Evaluate a condition expression
    function evaluateCondition(condition, ctx) {
      if (typeof condition === 'boolean') return condition;
      if (typeof condition !== 'string') return !!condition;

      // Simple comparisons: "$.count > 0", "$.items.length > 5", "$.status == 'active'"
      const comparisonMatch = condition.match(/^(.+?)\s*(==|!=|>|<|>=|<=)\s*(.+)$/);
      if (comparisonMatch) {
        const [, left, op, right] = comparisonMatch;
        const leftVal = evaluateExpression(left.trim(), ctx);
        const rightVal = evaluateExpression(right.trim(), ctx);

        switch (op) {
          case '==': return leftVal == rightVal;
          case '!=': return leftVal != rightVal;
          case '>': return Number(leftVal) > Number(rightVal);
          case '<': return Number(leftVal) < Number(rightVal);
          case '>=': return Number(leftVal) >= Number(rightVal);
          case '<=': return Number(leftVal) <= Number(rightVal);
        }
      }

      // Simple existence check: "$.items" returns truthy if items exist
      const value = evaluateExpression(condition, ctx);
      return !!value;
    }

    // Evaluate an expression (path, literal, or simple math)
    function evaluateExpression(expr, ctx) {
      if (typeof expr !== 'string') return expr;
      expr = expr.trim();

      // Number literal
      if (/^-?\d+(\.\d+)?$/.test(expr)) {
        return parseFloat(expr);
      }

      // String literal (single or double quoted)
      if ((expr.startsWith("'") && expr.endsWith("'")) ||
          (expr.startsWith('"') && expr.endsWith('"'))) {
        return expr.slice(1, -1);
      }

      // Arithmetic expressions: "$.minute % 2", "$.count + 1", etc.
      const arithmeticMatch = expr.match(/^(.+?)\s*([+\-*/%])\s*(.+)$/);
      if (arithmeticMatch) {
        const [, left, op, right] = arithmeticMatch;
        const leftVal = Number(evaluateExpression(left.trim(), ctx));
        const rightVal = Number(evaluateExpression(right.trim(), ctx));

        switch (op) {
          case '+': return leftVal + rightVal;
          case '-': return leftVal - rightVal;
          case '*': return leftVal * rightVal;
          case '/': return rightVal !== 0 ? leftVal / rightVal : 0;
          case '%': return leftVal % rightVal;
        }
      }

      // Path like $.foo.bar or $.foo.length
      if (expr.startsWith('$')) {
        const path = expr.replace(/^\$\.?/, '');
        const parts = path.split('.');

        let value = ctx;
        for (const part of parts) {
          if (value === null || value === undefined) return null;
          if (part === 'length' && Array.isArray(value)) {
            return value.length;
          }
          value = value[part];
        }
        return value;
      }

      // State reference
      if (expr.startsWith('state.')) {
        const key = expr.replace('state.', '');
        return ctx._state?.[key];
      }

      // Computed reference
      if (expr.startsWith('computed.')) {
        const key = expr.replace('computed.', '');
        return ctx._computed?.[key];
      }

      return expr;
    }

    function resolveBind(bind, ctx) {
      if (!ctx) return '';

      // Handle nested paths like $.item.content or $.results[0].id
      if (bind.includes('.') && !['$.id', '$.pubkey', '$.npub', '$.content', '$.time', '$.kind'].includes(bind.toLowerCase().replace('createdat', 'time').replace('created_at', 'time'))) {
        const value = resolvePath(bind, ctx);
        if (value !== null && value !== undefined) {
          return String(value);
        }
      }

      const path = bind.replace(/^\$\.?/, '').toLowerCase();

      switch (path) {
        case 'id': return ctx.id || ctx._item?.id || '';
        case 'pubkey': return ctx.pubkey || ctx._item?.pubkey || '';
        case 'npub': return ctx.npub || ctx.pubkey || ctx._item?.pubkey || '';
        case 'content': return ctx.content || ctx._item?.content || '';
        case 'time':
        case 'createdat':
        case 'created_at':
          const ts = ctx.created_at || ctx._item?.created_at;
          return ts ? new Date(ts * 1000).toLocaleString() : '';
        case 'kind': return String(ctx.kind || ctx._item?.kind || '');
        default:
          // Try to resolve as a path
          const resolved = resolvePath(bind, ctx);
          return resolved !== null && resolved !== undefined ? String(resolved) : '';
      }
    }

    function resolveTemplate(tmpl, ctx) {
      return tmpl.replace(/\{\{\s*\$\.?([^\}]+)\s*\}\}/g, (match, path) => {
        // Handle complex paths like $.item.pubkey
        const value = resolvePath('$.' + path, ctx);
        if (value !== null && value !== undefined) {
          return String(value);
        }
        return resolveBind('$.' + path, ctx);
      });
    }

    function escapeHtml(str) {
      if (!str) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // ===========================================
    // Bech32 encoding/decoding
    // ===========================================

    const BECH32_CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

    function bech32Decode(str) {
      str = str.toLowerCase();
      const pos = str.lastIndexOf('1');
      if (pos < 1 || pos + 7 > str.length) throw new Error('Invalid bech32');

      const hrp = str.slice(0, pos);
      const data = [];

      for (let i = pos + 1; i < str.length; i++) {
        const idx = BECH32_CHARSET.indexOf(str[i]);
        if (idx === -1) throw new Error('Invalid character');
        data.push(idx);
      }

      // Remove checksum (last 6 chars)
      const payload = data.slice(0, -6);

      // Convert 5-bit to 8-bit
      let acc = 0, bits = 0;
      const bytes = [];
      for (const val of payload) {
        acc = (acc << 5) | val;
        bits += 5;
        while (bits >= 8) {
          bits -= 8;
          bytes.push((acc >> bits) & 0xff);
        }
      }

      return { hrp, bytes: new Uint8Array(bytes) };
    }

    // Decode npub to hex pubkey
    function npubToHex(npub) {
      if (!npub.startsWith('npub1')) {
        throw new Error('Invalid npub');
      }
      const { bytes } = bech32Decode(npub);
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Bech32 encoding
    function bech32Encode(hrp, data) {
      // Convert 8-bit to 5-bit
      const values = [];
      let acc = 0, bits = 0;
      for (const byte of data) {
        acc = (acc << 8) | byte;
        bits += 8;
        while (bits >= 5) {
          bits -= 5;
          values.push((acc >> bits) & 31);
        }
      }
      if (bits > 0) {
        values.push((acc << (5 - bits)) & 31);
      }

      // Add checksum
      const checksum = bech32Checksum(hrp, values);
      values.push(...checksum);

      // Encode
      let result = hrp + '1';
      for (const v of values) {
        result += BECH32_CHARSET[v];
      }
      return result;
    }

    function bech32Checksum(hrp, data) {
      const values = bech32HrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
      const polymod = bech32Polymod(values) ^ 1;
      const checksum = [];
      for (let i = 0; i < 6; i++) {
        checksum.push((polymod >> (5 * (5 - i))) & 31);
      }
      return checksum;
    }

    function bech32HrpExpand(hrp) {
      const ret = [];
      for (const c of hrp) {
        ret.push(c.charCodeAt(0) >> 5);
      }
      ret.push(0);
      for (const c of hrp) {
        ret.push(c.charCodeAt(0) & 31);
      }
      return ret;
    }

    function bech32Polymod(values) {
      const GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
      let chk = 1;
      for (const v of values) {
        const b = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ v;
        for (let i = 0; i < 5; i++) {
          if ((b >> i) & 1) {
            chk ^= GEN[i];
          }
        }
      }
      return chk;
    }

    // Encode event ID to nevent (NIP-19 TLV format)
    function encodeNevent(eventId, relays = [], author = null, kind = null) {
      // Convert hex event ID to bytes
      const idBytes = [];
      for (let i = 0; i < eventId.length; i += 2) {
        idBytes.push(parseInt(eventId.substr(i, 2), 16));
      }

      // Build TLV data
      const tlv = [];

      // Type 0: event id (32 bytes)
      tlv.push(0, 32, ...idBytes);

      // Type 1: relay (optional, can have multiple)
      for (const relay of relays.slice(0, 2)) { // Max 2 relays to keep it short
        const relayBytes = new TextEncoder().encode(relay);
        tlv.push(1, relayBytes.length, ...relayBytes);
      }

      // Type 2: author pubkey (optional, 32 bytes)
      if (author) {
        const authorBytes = [];
        for (let i = 0; i < author.length; i += 2) {
          authorBytes.push(parseInt(author.substr(i, 2), 16));
        }
        tlv.push(2, 32, ...authorBytes);
      }

      // Type 3: kind (optional, 4 bytes big-endian)
      if (kind !== null) {
        tlv.push(3, 4,
          (kind >> 24) & 0xff,
          (kind >> 16) & 0xff,
          (kind >> 8) & 0xff,
          kind & 0xff
        );
      }

      return bech32Encode('nevent', new Uint8Array(tlv));
    }

    function parseNostrId(input) {
      input = input.trim();

      // Already hex?
      if (/^[0-9a-f]{64}$/i.test(input)) {
        return { type: 'hex', id: input.toLowerCase() };
      }

      // note1... (just the event id)
      if (input.startsWith('note1')) {
        const { bytes } = bech32Decode(input);
        const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        return { type: 'note', id: hex };
      }

      // nevent1... (TLV encoded)
      if (input.startsWith('nevent1')) {
        const { bytes } = bech32Decode(input);
        return parseTLV(bytes, 'nevent');
      }

      // naddr1... (TLV encoded)
      if (input.startsWith('naddr1')) {
        const { bytes } = bech32Decode(input);
        return parseTLV(bytes, 'naddr');
      }

      return { type: 'unknown', raw: input };
    }

    function parseTLV(bytes, type) {
      const result = { type };
      let i = 0;

      while (i < bytes.length) {
        const t = bytes[i++];
        const l = bytes[i++];
        const v = bytes.slice(i, i + l);
        i += l;

        if (t === 0) { // special (event id for nevent, identifier for naddr)
          result.id = Array.from(v).map(b => b.toString(16).padStart(2, '0')).join('');
        } else if (t === 1) { // relay
          result.relay = new TextDecoder().decode(v);
        } else if (t === 2) { // author
          result.author = Array.from(v).map(b => b.toString(16).padStart(2, '0')).join('');
        } else if (t === 3) { // kind
          result.kind = v.reduce((acc, b) => acc * 256 + b, 0);
        }
      }

      return result;
    }

    // ===========================================
    // Demo UI Specs
    // ===========================================

    const DEMO_SPECS = {
      // Basic poll demo (original)
      poll: {
        layout: 'card',
        title: 'Community Poll',
        elements: [
          { type: 'heading', value: "What's the best approach to malleable UI?" },
          { type: 'text', value: 'This entire UI is defined in JSON. The browser interprets it and renders HTML - no server required!' },
          { type: 'hr' },
          { type: 'text', value: 'Vote for your preferred approach:' },
          { type: 'container', style: 'options', children: [
            { type: 'button', label: 'Server-rendered', action: 'vote-server' },
            { type: 'button', label: 'Client JS', action: 'vote-client' },
            { type: 'button', label: 'Hybrid', action: 'vote-hybrid' }
          ]},
          { type: 'hr' },
          { type: 'heading', value: 'Event Data Bindings' },
          { type: 'text', value: 'UI specs can bind to event data:' },
          { type: 'data', bind: '$.id', label: 'Event ID: ' },
          { type: 'data', bind: '$.pubkey', label: 'Author: ' },
          { type: 'data', bind: '$.time', label: 'Created: ' }
        ],
        actions: [
          { id: 'vote-server', publish: { kind: 7, content: 'server-rendered', tags: [['e', '{{$.id}}']] }},
          { id: 'vote-client', publish: { kind: 7, content: 'client-js', tags: [['e', '{{$.id}}']] }},
          { id: 'vote-hybrid', publish: { kind: 7, content: 'hybrid', tags: [['e', '{{$.id}}']] }}
        ]
      },

      // QUERY + FOREACH demo: Fetch recent notes and display them
      feed: {
        layout: 'card',
        title: 'Recent Notes Feed',
        elements: [
          { type: 'heading', value: 'Recent Nostr Notes' },
          { type: 'text', value: 'This demo uses QUERY to fetch kind:1 notes from relays, then FOREACH to render each one.' },
          { type: 'hr' },
          {
            type: 'query',
            filter: { kinds: [1], limit: 5 },
            as: 'notes',
            timeout: 5000,
            children: [
              {
                type: 'if',
                condition: '$.notes.length > 0',
                then: [
                  { type: 'text', value: 'Found notes:' },
                  {
                    type: 'foreach',
                    items: '$.notes',
                    as: 'note',
                    template: {
                      type: 'container',
                      style: 'ui-event-preview',
                      children: [
                        { type: 'data', bind: '$.note.pubkey', label: 'By: ' },
                        { type: 'text', bind: '$.note.content' },
                        { type: 'data', bind: '$.note.created_at', label: 'At: ' }
                      ]
                    }
                  }
                ],
                else: [
                  { type: 'text', value: 'No notes found. Try refreshing!' }
                ]
              }
            ],
            empty: [
              { type: 'text', value: 'Loading notes from relays...' }
            ]
          }
        ]
      },

      // IF/ELSE demo: Conditional rendering
      conditional: {
        layout: 'card',
        title: 'Conditional Rendering Demo',
        state: {
          loggedIn: false,
          count: 3
        },
        elements: [
          { type: 'heading', value: 'If/Else Conditional Rendering' },
          { type: 'text', value: 'UI can show different content based on conditions.' },
          { type: 'hr' },
          { type: 'heading', value: 'State-based condition:' },
          {
            type: 'if',
            condition: '$.pubkey',
            then: [
              { type: 'text', value: 'You are connected! Your pubkey:' },
              { type: 'data', bind: '$.pubkey' }
            ],
            else: [
              { type: 'text', value: 'You are not connected. Connect with NIP-07 to see your pubkey.' }
            ]
          },
          { type: 'hr' },
          { type: 'heading', value: 'Comparison condition:' },
          {
            type: 'if',
            condition: '$.kind == 1',
            then: [
              { type: 'text', value: 'This is a kind:1 event (note)' }
            ],
            else: [
              { type: 'text', value: 'This is not a kind:1 event (kind: ' },
              { type: 'data', bind: '$.kind' },
              { type: 'text', value: ')' }
            ]
          }
        ]
      },

      // EMBED demo: Embed another malleable UI
      embed: {
        layout: 'card',
        title: 'Embed Demo',
        elements: [
          { type: 'heading', value: 'Embedding Other Content' },
          { type: 'text', value: 'The EMBED element can include another Nostr event inside this UI.' },
          { type: 'hr' },
          { type: 'text', value: 'To test this, paste an event ID below (or use query+foreach to dynamically embed content).' },
          { type: 'hr' },
          { type: 'heading', value: 'How it works:' },
          { type: 'text', value: '1. Use {"type": "embed", "event": "nevent1..."} in your spec' },
          { type: 'text', value: '2. The client fetches that event from relays' },
          { type: 'text', value: '3. If it\'s a UI spec, it renders as embedded UI' },
          { type: 'text', value: '4. If it\'s plain text, it shows the content' }
        ]
      },

      // STATE + COMPUTED demo
      counter: {
        layout: 'card',
        title: 'State & Computed Demo',
        state: {
          likes: 0
        },
        computed: {
          message: "$.state.likes > 0 ? 'Thanks for the likes!' : 'No likes yet'"
        },
        elements: [
          { type: 'heading', value: 'Local State Demo' },
          { type: 'text', value: 'This demo shows local state that can be modified.' },
          { type: 'hr' },
          { type: 'text', value: 'Current like count (from spec state):' },
          { type: 'state-value', key: 'likes' },
          { type: 'hr' },
          { type: 'text', value: 'Click to react (publishes kind:7):' },
          { type: 'button', label: ' Like', action: 'like' }
        ],
        actions: [
          { id: 'like', publish: { kind: 7, content: '+', tags: [['e', '{{$.id}}']] }}
        ]
      },

      // Advanced: Profile viewer using query
      profile: {
        layout: 'card',
        title: 'Profile Viewer',
        elements: [
          { type: 'heading', value: 'Profile Lookup' },
          { type: 'text', value: 'This demonstrates querying for a specific user\'s profile (kind:0).' },
          { type: 'hr' },
          {
            type: 'if',
            condition: '$.pubkey',
            then: [
              { type: 'text', value: 'Looking up your profile...' },
              {
                type: 'query',
                filter: { kinds: [0], authors: ['{{$.pubkey}}'], limit: 1 },
                as: 'profiles',
                children: [
                  {
                    type: 'if',
                    condition: '$.profiles.length > 0',
                    then: [
                      { type: 'heading', value: 'Your Profile:' },
                      {
                        type: 'foreach',
                        items: '$.profiles',
                        as: 'profile',
                        template: {
                          type: 'container',
                          children: [
                            { type: 'text', bind: '$.profile.content' }
                          ]
                        }
                      }
                    ],
                    else: [
                      { type: 'text', value: 'No profile found for your pubkey.' }
                    ]
                  }
                ]
              }
            ],
            else: [
              { type: 'text', value: 'Connect with NIP-07 to view your profile.' }
            ]
          }
        ]
      }
    };

    // Example prompts
    const EXAMPLE_PROMPTS = {
      poll: "Create a poll asking what people's favorite pizza topping is with options for pepperoni, mushrooms, pineapple, and plain cheese",
      rsvp: "Make an RSVP form for a Nostr meetup happening next Saturday at 7pm, with options for 'attending', 'maybe', and 'can't make it'",
      feedback: "Build a feedback form where users can enter their name and a message, then submit it",
      quiz: "Create a simple quiz asking 'What is the capital of France?' with options Paris, London, Berlin, Madrid",
      counter: "Make a simple like button that people can click to show appreciation"
    };

    // ===========================================
    // Alpine.js App
    // ===========================================

    function malleableApp() {
      return {
        // State
        mode: 'request', // 'request' or 'load'
        botNpub: DEFAULT_BOT_NPUB,
        requestText: '',
        eventInput: '',
        event: null,
        uiSpec: null,
        renderedHtml: '',
        error: null,
        loading: false,
        waiting: false,
        sentRequestId: null,
        relayStatus: 'disconnected',
        statusMessage: 'Not connected',
        userPubkey: null,
        isDirectSpec: false,
        successMessage: null,
        successNevent: null,

        // Relay pool
        pool: null,

        async init() {
          this.pool = new RelayPool();

          // Set global pool for query elements
          setGlobalPool(this.pool);

          // Check for NIP-07
          if (window.nostr) {
            try {
              this.userPubkey = await window.nostr.getPublicKey();
            } catch (e) {
              console.log('NIP-07 available but not connected');
            }
          }

          // Connect to relays
          this.relayStatus = 'connecting';
          this.statusMessage = 'Connecting to relays...';

          try {
            await this.pool.connect();
            this.relayStatus = 'connected';
            this.statusMessage = `Connected to ${this.pool.sockets.size} relays`;
          } catch (e) {
            this.relayStatus = 'error';
            this.statusMessage = 'Failed to connect to relays';
          }

          // Set up action executor
          window.executeAction = async (actionId) => {
            const { action, ctx } = window._malleableActions[actionId] || {};
            if (!action) return;

            await this.executeAction(action, ctx);
          };

          // Check URL params for event to load
          const params = new URLSearchParams(window.location.search);
          const eventParam = params.get('e') || params.get('event');
          if (eventParam) {
            this.mode = 'load';
            this.eventInput = eventParam;
            this.loadEvent();
          }
        },

        async connect() {
          if (!window.nostr) {
            this.error = 'No NIP-07 extension found. Install Alby, nos2x, or similar.';
            return;
          }

          try {
            this.userPubkey = await window.nostr.getPublicKey();
          } catch (e) {
            this.error = 'Failed to connect: ' + e.message;
          }
        },

        disconnect() {
          this.userPubkey = null;
        },

        setExample(name) {
          this.requestText = EXAMPLE_PROMPTS[name] || '';
        },

        async sendRequest() {
          if (!this.userPubkey) {
            this.error = 'Please connect your NIP-07 extension first';
            return;
          }

          if (!this.requestText.trim()) {
            this.error = 'Please describe the app you want';
            return;
          }

          this.error = null;
          this.event = null;
          this.uiSpec = null;
          this.renderedHtml = '';
          this.isDirectSpec = false;

          // Get bot pubkey from npub
          let botPubkey;
          try {
            botPubkey = npubToHex(this.botNpub.trim() || DEFAULT_BOT_NPUB);
          } catch (e) {
            this.error = 'Invalid bot NPub';
            return;
          }

          try {
            // Create NIP-90 DVM job request (kind:5666)
            const requestEvent = {
              kind: KIND_JOB_REQUEST,
              content: '',  // NIP-90: input goes in tags, not content
              tags: [
                ['i', this.requestText.trim(), 'text'],  // NIP-90 input tag
                ['output', 'application/json'],          // Expected output format
                ['p', botPubkey]                         // Preferred service provider
              ],
              created_at: Math.floor(Date.now() / 1000)
            };

            // Sign with NIP-07
            const signedEvent = await window.nostr.signEvent(requestEvent);
            this.sentRequestId = signedEvent.id;

            // Publish to relays
            await this.pool.publish(signedEvent);
            console.log('Published DVM job request:', signedEvent.id);

            // Now wait for the bot's reply
            this.waiting = true;

            // Subscribe for job results (kind:6666) that reference our request
            const replyFilter = {
              kinds: [KIND_JOB_RESULT],
              authors: [botPubkey],
              '#e': [signedEvent.id],
              since: signedEvent.created_at
            };

            try {
              const replyEvent = await this.pool.waitForReply(replyFilter, 120000); // 2 min timeout

              this.waiting = false;
              this.event = replyEvent;
              this.uiSpec = parseUISpec(replyEvent.content);

              if (this.uiSpec) {
                const ctx = {
                  id: replyEvent.id,
                  pubkey: replyEvent.pubkey,
                  created_at: replyEvent.created_at,
                  kind: replyEvent.kind,
                  content: replyEvent.content
                };
                this.renderedHtml = await renderUISpec(this.uiSpec, ctx);
              } else {
                // Not a UI spec - show raw content
                this.error = 'Bot replied but response is not a UI spec';
              }

            } catch (e) {
              this.waiting = false;
              this.error = e.message;
            }

          } catch (e) {
            this.waiting = false;
            this.error = 'Failed to send request: ' + e.message;
          }
        },

        async loadEvent() {
          this.error = null;
          this.event = null;
          this.uiSpec = null;
          this.renderedHtml = '';
          this.isDirectSpec = false;

          const input = this.eventInput.trim();
          if (!input) {
            this.error = 'Please enter an event ID or UI spec';
            return;
          }

          // Check if it's direct JSON
          if (input.startsWith('{')) {
            const spec = parseUISpec(input);
            if (spec) {
              this.isDirectSpec = true;
              this.uiSpec = spec;
              const ctx = {
                id: 'direct-spec',
                pubkey: this.userPubkey || 'not-connected',
                created_at: Math.floor(Date.now() / 1000),
                kind: 0,
                content: input
              };
              this.renderedHtml = await renderUISpec(spec, ctx);
              return;
            } else {
              this.error = 'Invalid UI spec JSON';
              return;
            }
          }

          // Parse as Nostr identifier
          this.loading = true;

          try {
            const parsed = parseNostrId(input);

            let filter = {};
            if (parsed.type === 'hex' || parsed.type === 'note' || parsed.type === 'nevent') {
              filter = { ids: [parsed.id], limit: 1 };
            } else if (parsed.type === 'naddr') {
              filter = {
                kinds: [parsed.kind],
                authors: [parsed.author],
                '#d': [parsed.id],
                limit: 1
              };
            } else {
              this.error = 'Unrecognized identifier format';
              this.loading = false;
              return;
            }

            const event = await this.pool.fetchEvent(filter);

            if (!event) {
              this.error = 'Event not found';
              this.loading = false;
              return;
            }

            this.event = event;
            this.uiSpec = parseUISpec(event.content);

            if (this.uiSpec) {
              const ctx = {
                id: event.id,
                pubkey: event.pubkey,
                created_at: event.created_at,
                kind: event.kind,
                content: event.content
              };
              this.renderedHtml = await renderUISpec(this.uiSpec, ctx);
            }

          } catch (e) {
            this.error = 'Failed to load event: ' + e.message;
          }

          this.loading = false;
        },

        async loadDemo(name = 'poll') {
          this.error = null;
          this.event = null;
          this.isDirectSpec = true;

          const spec = DEMO_SPECS[name] || DEMO_SPECS.poll;
          this.uiSpec = spec;

          const ctx = {
            id: 'demo-' + name,
            pubkey: this.userPubkey || 'demo-pubkey',
            created_at: Math.floor(Date.now() / 1000),
            kind: 1,
            content: JSON.stringify(spec)
          };

          this.renderedHtml = await renderUISpec(spec, ctx);
          this.eventInput = JSON.stringify(spec, null, 2);
        },

        clear() {
          this.eventInput = '';
          this.requestText = '';
          this.event = null;
          this.uiSpec = null;
          this.renderedHtml = '';
          this.error = null;
          this.isDirectSpec = false;
          this.waiting = false;
          this.sentRequestId = null;
          this.successMessage = null;
          this.successNevent = null;
        },

        async executeAction(action, ctx) {
          if (action.link) {
            const url = resolveTemplate(action.link, ctx);
            window.location.href = url;
            return;
          }

          if (action.publish) {
            if (!window.nostr) {
              this.error = 'NIP-07 extension required to publish events';
              return;
            }

            if (!this.userPubkey) {
              this.error = 'Please connect your NIP-07 extension first';
              return;
            }

            try {
              // Resolve template in content
              let content = resolveTemplate(action.publish.content, ctx);

              // Check for input bindings like {{input:fieldname}}
              content = content.replace(/\{\{input:(\w+)\}\}/g, (match, fieldName) => {
                const input = document.querySelector(`[name="${fieldName}"]`);
                return input ? input.value : '';
              });

              // Resolve template in tags
              const tags = (action.publish.tags || []).map(tag =>
                tag.map(v => resolveTemplate(v, ctx))
              );

              const event = {
                kind: action.publish.kind,
                content: content,
                tags: tags,
                created_at: Math.floor(Date.now() / 1000)
              };

              // Sign with NIP-07
              const signedEvent = await window.nostr.signEvent(event);

              // Publish to relays
              const relays = await this.pool.publish(signedEvent);

              // Show success message with nevent ID
              this.error = null;
              this.successMessage = `Published to ${relays.length} relays!`;
              this.successNevent = encodeNevent(
                signedEvent.id,
                relays.slice(0, 2),  // Include up to 2 relay hints
                signedEvent.pubkey,
                signedEvent.kind
              );

            } catch (e) {
              this.error = 'Failed to publish: ' + e.message;
            }
          }
        },

        dismissSuccess() {
          this.successMessage = null;
          this.successNevent = null;
        },

        async copyNevent() {
          if (this.successNevent) {
            try {
              await navigator.clipboard.writeText(this.successNevent);
              // Brief feedback
              const btn = document.querySelector('.success-box .copy-btn');
              if (btn) {
                const original = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = original, 1500);
              }
            } catch (e) {
              console.error('Failed to copy:', e);
            }
          }
        }
      };
    }
  </script>
</body>
</html>
